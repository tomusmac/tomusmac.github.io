<!DOCTYPE html>
<html>
<head>
<title>Egzamin C++</title>
<meta charset="UTF-8">
<style>
body { font-family: sans-serif; }
.card { border: 1px solid #ccc; margin-bottom: 20px; padding: 10px; }
.question { font-weight: bold; }
.code { font-family: monospace; background-color: #f0f0f0; padding: 5px; }
.options { margin-top: 10px; }
.option { display: block; margin-bottom: 5px; }
.correct { color: green; }
.incorrect { color: red; }
.explanation { margin-top: 10px; font-style: italic; }
</style>
</head>
<body>

<div class="card" data-correct="A,D" data-explanation="Poprawny output kodu, oraz typ iteratora z vectora par">
    <div class="question">Jaki będzie output poniższego kodu?</div>
    <pre class="code">std::vector&lt;std::pair&lt;int, int&gt;&gt; vec = { {1, 2}, {3, 4}, {4, 5} };
for (auto it = vec.cbegin(); it != vec.cend(); ++it)
    std::cout &lt;&lt; it->second;</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q1" value="A"> A: 245</label>
        <label class="option"><input type="checkbox" name="q1" value="B"> B: 134</label>
        <label class="option"><input type="checkbox" name="q1" value="C"> C: Typem zmiennej `it` bedzie `int`</label>
        <label class="option"><input type="checkbox" name="q1" value="D"> D: Typem zmiennej `it` bedzie `std::vector&lt;std::pair&lt;int, int&gt;&gt;::const_iterator</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
    <p class="explanation"></p>
</div>

<div class="card" data-correct="D" data-explanation="Oto poprawna odpowiedz.">
    <div class="question">Wskaż kod reprezentujący klasę szablonową zawierającą tablicę elementów typu określonego przez pierwszy parametr szablonowy. Rozmiar tablicy ma być zdefiniowany przez drugi parametr szablonowy.</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q2" value="A"> A: template&lt;typename Type, int Size&gt; class Tablica { Size A[Type]; };</label>
        <label class="option"><input type="checkbox" name="q2" value="B"> B: template&lt;typename T, int S0&gt; class Array1 { T A[] = new A[S0]; };</label>
        <label class="option"><input type="checkbox" name="q2" value="C"> C: class Array2(Type, Size) { Type A[size]; };</label>
        <label class="option"><input type="checkbox" name="q2" value="D"> D: template&lt;typename T1, int S1&gt; class Array { T1 A[S1]; };</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
    <p class="explanation"></p>
</div>

<div class="card" data-correct="A,D" data-explanation="enum nie ma etykiety tego w środku oraz dynamic cast dziala tylko na wskaznikach">
    <div class="question">Dany jest poniższy fragment kodu. Które linie spowodują błąd kompilacji?</div>
    <pre class="code">enum class Animal {
    FISH,
    REPTILE,
    BIRD
};
//A
Animal f = FISH;
//B
Animal r = Animal::REPTILE;
//C
int i = (int)r;
//D
int j = dynamic_cast&lt;int&gt;(r);</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q3" value="A"> A) 1 nie ma etykiety tego w środku enuma dla FISH. (Nie po ludzku Brak operatora zasięgu)</label>
        <label class="option"><input type="checkbox" name="q3" value="B"> B) 2</label>
        <label class="option"><input type="checkbox" name="q3" value="C"> C) 3</label>
        <label class="option"><input type="checkbox" name="q3" value="D"> D) 4 (nie ma wskaźnika przy incie) i nie jest klasą dziedziczną</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="C" data-explanation="C jest prawidlowa odpowiedzi">
    <div class="question">Wskaż poprawny nagłówek konstruktora kopiującego oraz operatora przypisania przenoszącego dla klasy o nazwie ABC.</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q4" value="A"> A: ABC(ABC&& rhs);  ABC operator=(const ABC&& rhs);</label>
        <label class="option"><input type="checkbox" name="q4" value="B"> B: ABC(const ABC& rhs); ABC& operator=(const ABC& rhs);</label>
        <label class="option"><input type="checkbox" name="q4" value="C"> C: ABC(const ABC&& rhs); ABC& operator=(const ABC&& rhs);</label>
        <label class="option"><input type="checkbox" name="q4" value="D"> D: ABC(const ABC& rhs); ABC operator=(ABC& rhs);</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="C" data-explanation="C jest prawidlowa odpowiedzi">
    <div class="question">Wskaż poprawny nagłówek konstruktora kopiującego oraz operatora przypisania kopiującego dla klasy o nazwie ABC.</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q5" value="A"> A: ABC(ABC& rhs);  ABC operator=(const ABC&& rhs);</label>
        <label class="option"><input type="checkbox" name="q5" value="B"> B: ABC(const ABC& rhs); ABC operator=(const ABC& rhs);</label>
        <label class="option"><input type="checkbox" name="q5" value="C"> C: ABC(const ABC& rhs);  ABC& operator=(const ABC& rhs);</label>
        <label class="option"><input type="checkbox" name="q5" value="D"> D: ABC(ABC&& rhs); ABC operator=(ABC&& rhs);</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="A,D" data-explanation="A: Dlugosc Tytusa to 5, D: Atome po resizie zwraca dlugosc 3">
    <div class="question">Co zwróci metoda `length()` dla łańcuchów `a`, `b`, `c` po wykonaniu poniższego kodu:</div>
    <pre class="code">std::string a, b, c;
a += "Tytus";
a.reserve(7);
b = "Romek";
b.reserve(3);
c = "Atome";
c.resize(3, 'k');</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q6" value="A"> A) a.length() zwróci 5</label>
        <label class="option"><input type="checkbox" name="q6" value="B"> B) b.length() zwróci 8</label>
        <label class="option"><input type="checkbox" name="q6" value="C"> C) b.length() zwróci 3</label>
        <label class="option"><input type="checkbox" name="q6" value="D"> D) c.length() zwróci 3</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="A" data-explanation="Wynik multiseta po tych operacjach">
    <div class="question">Jaki będzie output poniższego kodu?</div>
    <pre class="code">std::multiset&lt;int&gt; s;
s.insert(10);
s.insert(5);
s.insert(10);
s.insert(15);
s.insert(5);

std::cout &lt;&lt; s.size() &lt;&lt; " ";
for (auto&amp; e : s)
    std::cout &lt;&lt; e &lt;&lt; " ";</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q7" value="A"> A) Wyświetlone zostanie : 5 5 5 10 10 15</label>
        <label class="option"><input type="checkbox" name="q7" value="B"> B) Kod się nie skompiluje ponieważ zmienna e musi const</label>
        <label class="option"><input type="checkbox" name="q7" value="C"> C) Wyświetlone zostanie : 3 5 5 10 10 15</label>
        <label class="option"><input type="checkbox" name="q7" value="D"> D) Wyświetlone zostanie : 3 5 10 15</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="A" data-explanation="Wynik seta po tych operacjach">
    <div class="question">Jaki będzie output poniższego kodu?</div>
    <pre class="code">std::set&lt;int&gt; s;
s.insert(10);
s.insert(5);
s.insert(10);
s.insert(15);
s.insert(5);

std::cout &lt;&lt; s.size() &lt;&lt; " ";
for (auto&amp; e : s)
    std::cout &lt;&lt; e &lt;&lt; " ";</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q8" value="A"> A) Wyświetlone zostanie : 3 5 10 15</label>
        <label class="option"><input type="checkbox" name="q8" value="B"> B) Wyświetlone zostanie : 3 5 5 10 10 15</label>
        <label class="option"><input type="checkbox" name="q8" value="C"> C) Wyświetlone zostanie : 5 5 5 10 10 15</label>
        <label class="option"><input type="checkbox" name="q8" value="D"> D) Kod się nie skompiluje ponieważ zmienna e nie może być const</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="C" data-explanation="W klasie domyslnie wszystko jest private">
    <div class="question">Jaki problem dostrzegasz w poniższym kodzie?</div>
    <pre class="code">class DynamicArray {
    void* data;
    ~DynamicArray() { delete[] data; }
    DynamicArray(int size) { data = (void*) new char[size]; }
};

DynamicArray array(4);</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q9" value="A"> A Operator new powinien tworzyc tablice typu void zamiast char</label>
        <label class="option"><input type="checkbox" name="q9" value="B"> B konstruktor nie moze byc zdefiniowany po destruktorze - pamiec jest juz zwolniona</label>
        <label class="option"><input type="checkbox" name="q9" value="C"> C konstruktor i destruktor powinny byc publiczne by utworzyc instancje obiektu poza klasa</label>
        <label class="option"><input type="checkbox" name="q9" value="D"> D obiekt array powinien przyjac argument typu wskaznikowego</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="a" data-explanation="W klasie domyslnie wszystko jest private">
    <div class="question">Jaki problem dostrzegasz w poniższym kodzie?</div>
    <pre class="code">class DynamicArray {
    void* data;
    ~DynamicArray() { delete[] data; }
    DynamicArray(int size) { data = (void*) new char[size]; }
};</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q10" value="a"> a) Brak dostępu do konstruktora i destruktora spoza klasy.</label>
        <label class="option"><input type="checkbox" name="q10" value="b"> b) Destruktor nie może być zdefiniowany przed konstruktorem - pamięć nie jest jeszcze zaalokowana.</label>
        <label class="option"><input type="checkbox" name="q10" value="c"> c) Obiekt array powinien być utworzony operatorem new.</label>
        <label class="option"><input type="checkbox" name="q10" value="d"> d) Konwersja wskaźnika char* na void* jest nielegalna.</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="std::sort(V.begin(), V.end(), [](int a, int b)->bool { return a > b; }),std::sort(V.rbegin(), V.rend(), std::less<int>())" data-explanation="Sortowanie w kolejnosc nierosnaca">
    <div class="question">Który fragment kodu zrealizuje nierosnące sortowanie wektora `V` liczb całkowitych?</div>
    <pre class="code">std::vector&lt;int&gt; V;</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q11" value="std::sort(V.begin(), V.end(), [](int a, int b)->bool { return V[a] > V[b]; })"> std::sort(V.begin(), V.end(), [](int a, int b)->bool { return V[a] > V[b]; })</label>
        <label class="option"><input type="checkbox" name="q11" value="V.sort(std::greater<int>())"> V.sort(std::greater&lt;int&gt;);</label>
        <label class="option"><input type="checkbox" name="q11" value="std::sort(V.begin(), V.end(), [](int a, int b)->bool { return a > b; })"> std::sort(V.begin(), V.end(), [](int a, int b)->bool { return a > b; });</label>
        <label class="option"><input type="checkbox" name="q11" value="std::sort(V.rbegin(), V.rend(), std::less<int>())"> std::sort(V.rbegin(), V.rend(), std::less&lt;int&gt;);</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="A,B" data-explanation="A,B sa poprawne">
    <div class="question">Które z poniższych fragmentów kodu są prawidłowe?</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q12" value="A"> A: int a; int *pa; pa=&a;</label>
        <label class="option"><input type="checkbox" name="q12" value="B"> B: int d; int &rd=d;</label>
        <label class="option"><input type="checkbox" name="q12" value="C"> C: int c; int *pc; &pc=c;</label>
        <label class="option"><input type="checkbox" name="q12" value="D"> D: int b; int *pb = *b;</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="a,b,c" data-explanation="to wszystko pasuje do list">
    <div class="question">Zaznacz zdania prawdziwe związane z iteratorem klasy `list`.</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q13" value="a"> a.Można na nim wykonywać operację inkrementacji.</label>
        <label class="option"><input type="checkbox" name="q13" value="b"> b.Jest to operator dwukierunkowy.</label>
        <label class="option"><input type="checkbox" name="q13" value="c"> c.Można na nim wykonywać operację dekrementacji.</label>
        <label class="option"><input type="checkbox" name="q13" value="d"> d.Jest to iterator swobodnego dostępu.</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="A,C" data-explanation="a,c pasuja do zapisu z klasa line">
    <div class="question">Dana jest klasa `Line` reprezentująca prostą o równaniu `y = ax + b = 0`. Klasa posiada pola `a`, `b` (liczby zmiennoprzecinkowe pojedynczej precyzji). Które zapisy w klasie `Line` są poprawne składniowo i mają sens?</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q14" value="A"> A: Line(const Line& other) : a(other.a), b(other.b) {}</label>
        <label class="option"><input type="checkbox" name="q14" value="B"> B: line calc_y(float x);</label>
        <label class="option"><input type="checkbox" name="q14" value="C"> C: float calc_y(float x) {return a*x + b;}</label>
        <label class="option"><input type="checkbox" name="q14" value="D"> D: Line() : 1(a), 0(b) {}</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="D" data-explanation="D jest poprawne">
    <div class="question">Dany jest fragment kodu:</div>
    <pre class="code">class Base {
public:
    virtual ~Base() { }
};

class A : public Base { };
class B : public Base { };

int main() {
    Base* ptr = new B;
    if(dynamic_cast&lt;A*&gt;(ptr))
        cout &lt;&lt; "A";
    else if(dynamic_cast&lt;B*&gt;(ptr))
        cout &lt;&lt; "B";
    else
        cout &lt;&lt; "None";
    delete ptr;
}</pre>
    <div class="question">Jaki będzie output?</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q15" value="A"> A) Wyświetlenie None</label>
        <label class="option"><input type="checkbox" name="q15" value="B"> B) Wyświetlenie A</label>
        <label class="option"><input type="checkbox" name="q15" value="C"> C) Dojdzie do wysieku pamięci</label>
        <label class="option"><input type="checkbox" name="q15" value="D"> D) Wyświetlenie B</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="c,d" data-explanation="c,d sa poprawne">
    <div class="question">Które stwierdzenia dotyczące operacji przeniesienia są poprawne?</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q16" value="a"> a) Wyrazenie Buffer (const Buffer&& t) jest poprawnym nagłówkiem konstruktora przenoszącego.</label>
        <label class="option"><input type="checkbox" name="q16" value="b"> b) Konstruktor przenoszący zwykle jest wolniejszy od kopiującego. - jest szybszy pzrenoszący bo wykopystuje referencję so r wartości</label>
        <label class="option"><input type="checkbox" name="q16" value="c"> c) Instrukcja a = std:move(b) spowoduje wywołanie przenoszącego operatora przypisania</label>
        <label class="option"><input type="checkbox" name="q16" value="d"> d) Do obiektu, który przekazano jako argument konstruktora przenoszącego, można potem przypisać coś innego.</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="A,C" data-explanation="a,c sa poprawne">
    <div class="question">Klasą abstrakcyjną jest:</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q17" value="A"> A) class Irunner {virtual void Run() = 0;};</label>
        <label class="option"><input type="checkbox" name="q17" value="B"> B) class abstract {virtual void run() {};};</label>
        <label class="option"><input type="checkbox" name="q17" value="C"> C) class Banana : public Fruit {virtual float Consume() = 0;};</label>
        <label class="option"><input type="checkbox" name="q17" value="D"> D) class Apple {int consume();};</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="B,D" data-explanation="b,d sa poprawne">
    <div class="question">Zaznacz klasy, których obiekty można utworzyć:</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q18" value="A"> A) class Banana : public Fruit {virtual float Consume() = 0;   virtual ~Banana();};</label>
        <label class="option"><input type="checkbox" name="q18" value="B"> B) class Abstract {virtual void Run() {}};</label>
        <label class="option"><input type="checkbox" name="q18" value="C"> C) class IRunner {	virtual void Run() = 0;};</label>
        <label class="option"><input type="checkbox" name="q18" value="D"> D) class Apple {int Consume();};</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
     <p class="explanation"></p>
</div>

<div class="card" data-correct="D" data-explanation="d jest prawidlowe">
    <div class="question">Wskaż kod reprezentujący klasę szablonową zawierającą tablicę elementów typu określonego przez pierwszy parametr szablonowy. Rozmiar tablicy ma być zdefiniowany przez drugi parametr szablonowy.</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q19" value="A"> A) template&lt;typename Type, int Size&gt; class Tablica {Size A[Type];};</label>
        <label class="option"><input type="checkbox" name="q19" value="B"> B) template&lt;typename T, int S&gt; class Array {T A[]=new A[S];};</label>
        <label class="option"><input type="checkbox" name="q19" value="C"> C) class Array(Type, Size) {TypeA[Size];};</label>
        <label class="option"><input type="checkbox" name="q19" value="D"> D) template&lt;typename T, int S&gt; class Array {T A[S];};</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="a,c" data-explanation="A i C sa prawdziwe">
    <div class="question">Wskaż zdania prawdziwe związane z dziedziczeniem publicznym (public) oraz chronionym (protected)?</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q20" value="a"> a. Dziedziczenie publiczne nie zmienia kwalifikatorów dostępu klasy bazowej w klasie pochodnej, a chronione zmienia kwalifikator public na protected.</label>
        <label class="option"><input type="checkbox" name="q20" value="b"> b. W przypadku dziedziczenia publicznego dziedziczone są wszystkie składowe klasy bazowej poza prywatnymi. W przypadku dziedziczenia chronionego dziedziczone są jedynie składowe publiczne. Obiekt klasy pochodnej może być więc mniejszego rozmiaru niż obiekt klasy bazowej.</label>
        <label class="option"><input type="checkbox" name="q20" value="c"> c. W obu przypadkach dziedziczone są wszystkie składowe klasy bazowej (pola i metody), aczkolwiek do składowych prywatnych nie można się odwołać.</label>
        <label class="option"><input type="checkbox" name="q20" value="d"> d. W obu przypadkach dziedziczone są jedynie składowe (pola i metody) chronione i publiczne.</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="A" data-explanation="A jest poprawne poniewaz q nie istnieje i nie jest widoczne dla lambdy w D">
    <div class="question">Który z poniższych algorytmów wywołano poprawnie?</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q21" value="A"> A std::transform(A.begin(), A.end(), B.begin(), [](double a)-> double {return 2 * a; });</label>
        <label class="option"><input type="checkbox" name="q21" value="B"> B std::transform(A.begin(), B.begin(), C.begin(), [](double a, int b)->double {return a + b});</label>
        <label class="option"><input type="checkbox" name="q21" value="C"> C std::transform(A.begin(), A.end(), B.begin(), []{}->double {return 2 * A;});</label>
        <label class="option"><input type="checkbox" name="q21" value="D"> D std::transform(A.begin(), A.end(), A.begin(), [q](double a)->double {return a/q});</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="d" data-explanation="D jest poprawne">
    <div class="question">Wskutek jego wykonania</div>
    <pre class="code">class Base {
public:
    void Who() { std::cout &lt;&lt; "Base "; }
};

class Child : public Base {
public:
    void Who() {
        Base::Who();
        std::cout &lt;&lt; "Child ";
    }
};

int main() {
    Base* b1 = new Base;
    Base* b2 = new Child;
    b1->Who();
    b2->Who();
    delete b1;
    delete b2;}</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q22" value="a"> a. dojdzie do wycieku pamięci.</label>
        <label class="option"><input type="checkbox" name="q22" value="b"> b. zostanie wyświetione: Base Base Child.</label>
        <label class="option"><input type="checkbox" name="q22" value="c"> c. zostanie wyświetlone: Base Child.</label>
        <label class="option"><input type="checkbox" name="q22" value="d"> d. zostanie wyświetlone: Base Base.</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="b,d" data-explanation="B i D sa poprawne">
    <div class="question">Dana jest klasa QuadraticFunction reprezentująca funkcję kwadratową o równaniu f(x) = ax^2 + bx + c. Klasa posiada pola a, b, c (liczby zmiennoprzecinkowe pojedynczej precyzji). Który z poniższych zapisów w klasie jest poprawny składniowo i ma sens.</div>
    <pre class="code">class QuadraticFunction {
    float a, b, c;
Dana jest klasa QuadraticFunction reprezentująca funkcję kwadratową o równaniu f(x) = ax^2 + bx + c. Klasa posiada pola a, b, c (liczby zmiennoprzecinkowe pojedynczej precyzji). Który z poniższych zapisów w klasie jest poprawny składniowo i ma sens.</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q23" value="a"> a QuadraticFunction(const QuadraticFunction& other) { this = other; }</label>
        <label class="option"><input type="checkbox" name="q23" value="b"> b QuadraticFunction(float a, float b, float c);</label>
        <label class="option"><input type="checkbox" name="q23" value="c"> c QuadraticFunction() : a(a), b(b), c(c) {}</label>
        <label class="option"><input type="checkbox" name="q23" value="d"> d QuadraticFunction(const QuadraticFunction& other) : a(other.a), b(other.b), c(other.c) {}</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="a,b,d" data-explanation="A,B,D poprawne bo to sa cechy lambdy a c juz nie">
    <div class="question">Które stwierdzenia dotyczące wyrażenia lambda są prawdziwe.</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q24" value="a"> a.Wyrażenia lambda są szczególnie przydatne w połączeniu z algorytmami STL.</label>
        <label class="option"><input type="checkbox" name="q24" value="b"> b.wyrażenie lambda może być przypisane do zmiennej.</label>
        <label class="option"><input type="checkbox" name="q24" value="c"> c.Do wyrażenia lambda nie można przekazać argumentów.</label>

        <label class="option"><input type="checkbox" name="q24" value="d"> d.Wyrażenie lambda to funkcja anonimowa.</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="B" data-explanation="Tworzenie obiektu u1 spowoduje błąd kompilacji, bo u1 jest unique a probujesz z shared">
    <div class="question">Znana jest klasa Q posiadająca publiczna metodę fun(). Które zdania dotyczące poniższego fragmentu kodu są prawdziwe?</div>
    <pre class="code">Q *q = new Q();
std::shared_ptr s1(q);
si->fun();
std::unique_ptr<Q> u1(s1);
std::unique_ptr<Q> u2 = std::move(s1);</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q25" value="A"> A Tworzenie obiektu s2 spowoduje błąd kompilacji</label>
        <label class="option"><input type="checkbox" name="q25" value="B"> B Destruktor obiektu wskazywanego przez q zostanie wywołany dwukrotnie</label>
        <label class="option"><input type="checkbox" name="q25" value="C"> C Wywolanie metody fun spowoduje blad kompilacji</label>
        <label class="option"><input type="checkbox" name="q25" value="D"> D Tworzenie obiektu u2 spowoduje blad kompilacji</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="D" data-explanation="trzeba uzyc akumulacji i find if">
    <div class="question">Które algorytmy umożliwiaja znalezienie w wektorze X pierwszej wartosci wiekszej od sredniej elemetow X</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q26" value="A"> A std::sum i std::binary_search</label>
        <label class="option"><input type="checkbox" name="q26" value="B"> B std::average i std::find_if</label>
        <label class="option"><input type="checkbox" name="q26" value="C"> C std::accumulate i std::find</label>
        <label class="option"><input type="checkbox" name="q26" value="D"> D std::accumulate i std::find_if</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="C,D" data-explanation="linia 2,3 zwracaja blad kompilacji">
    <div class="question">Dla zadanego fragmentu kodu</div>
    <pre class="code">class X{
    int& Get5() {
        int a = 5; return a;
    }
    X& GetMe() {
        return *this;
    }
};</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q27" value="A"> A Blad wystepuje w liniach 5,6</label>
        <label class="option"><input type="checkbox" name="q27" value="B"> B Blad wystapi dopiero podczas uruchomienia programu</label>
        <label class="option"><input type="checkbox" name="q27" value="C"> C Blad wystepuje w liniach 2,3</label>
        <label class="option"><input type="checkbox" name="q27" value="D"> D Blad spowoduje niepowodzenie kompilacji</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="A,D" data-explanation="A i D sa prawdziwe">
    <div class="question">Jakie jest znaczenie kwalifikatora const umieszczonego w klasie po nazwie metody i liscie parametrow? przyklad:</div>
    <pre class="code">class C{
    int f() const;
};</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q28" value="A"> A Oznacza to z metoda nie moze modyfikowac obiektu, na rzecz ktorego zostala wywolana</label>
        <label class="option"><input type="checkbox" name="q28" value="B"> B oznacza to ze metoda jest stala</label>
        <label class="option"><input type="checkbox" name="q28" value="C"> C oznacza to ze metoda zwraca stala wartosc</label>
        <label class="option"><input type="checkbox" name="q28" value="D"> D oznacza to ze metoda moze byc wywolana na rzecz obiektow stalych</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="A" data-explanation="Base jest poprawne poniewaz wywolujesz Who z obiektu klasy Base">
    <div class="question">Dany jest fragment kodu:</div>
    <pre class="code">#include <iostream>
using namespace std;

class Base {
public:
    void Who() {
        cout << "Base ";
    }
};

class Child : public Base {
public:
    void Who() {
        Base::Who();
        cout << "Child ";
    }
};

int main() {
    Base* b1 = new Base;
    Base* b2 = new Child;
    b1->Who();
    b2->Who();
    delete b1;
    delete b2;}</pre>
    <div class="question">Wskutek jego wykonania</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q29" value="A"> A zostanie wyswietlone: Base Base</label>
        <label class="option"><input type="checkbox" name="q29" value="B"> B zostanie wyswietlone: Base Base Child</label>
        <label class="option"><input type="checkbox" name="q29" value="C"> C dojdzie do wycieku pamieci</label>
        <label class="option"><input type="checkbox" name="q29" value="D"> D zostanie wyswietlone Base Child</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="A,B,C,D" data-explanation="Wszystkie odpowiedzi pasuja">
    <div class="question">Zaznacz zdania prawdziwe związane z iteratorem klasy wektor</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q30" value="A"> A Mozna na nim wykonywac operacje inkrementacji</label>
        <label class="option"><input type="checkbox" name="q30" value="B"> B mozna na nim wykonywac operacje dekrementacji</label>
        <label class="option"><input type="checkbox" name="q30" value="C"> C mozna na nim wykonywac operacje zwiekszenia o 7 (it +=7; gdzie it to rozwazny iterator)</label>
        <label class="option"><input type="checkbox" name="q30" value="D"> D jest to iterator swobodnego dostepu</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="B" data-explanation="Nie mozna inicjalizowac z shared_ptr bo jedyny w swoim rodzaju musi byc">
    <div class="question">Znana jest klasa Q posiadająca publiczna metodę fun(). ktore zdania dotyczace ponizszego fragmentu kodu sa prawdziwe</div>
    <pre class="code">Q *q =new Q();

std::shared_ptr<Q> s1(q);
(*s1).fun();
std::shared_ptr<Q> s2 = std::move(s1);
std::unique_ptr<Q> u1(s1);</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q31" value="A"> A Tworzenie obiektu s2 spowoduje błąd kompilacji</label>
        <label class="option"><input type="checkbox" name="q31" value="B"> B Tworzenie obiektu u1 spowoduje błąd kompilacji</label>
        <label class="option"><input type="checkbox" name="q31" value="C"> C destruktor obiektu wskazywanego przez q zostanie wywolany dwukrotnie</label>
        <label class="option"><input type="checkbox" name="q31" value="D"> D wywolanie metody fun spowoduje blad kompilacji</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="A" data-explanation="rzucenie powoduje blad i zakonczenie dzialania aplikacji">
    <div class="question">Co sie stanie jesli rzucony wyjatek nie zostanie przechwycony</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q32" value="A"> A Program zakonczy działanie błędem</label>
        <label class="option"><input type="checkbox" name="q32" value="B"> B Program sie nie skompiluje</label>
        <label class="option"><input type="checkbox" name="q32" value="C"> C Nic</label>
        <label class="option"><input type="checkbox" name="q32" value="D"> D Wyjątek dla którego nie istnieje mechanizm przechwycenia nie zostanie wcale rzucony</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="A,B,D" data-explanation="ofstream,fstream,ifstream wszystkie obsluguja pliki">
    <div class="question">Jaka klasa (jakie klasy) znajdujaca sie w bibliotece standardowej sluzy do obslugi plikow?</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q33" value="A"> A ofstream</label>
        <label class="option"><input type="checkbox" name="q33" value="B"> B fstream</label>
        <label class="option"><input type="checkbox" name="q33" value="C"> C sstream</label>
        <label class="option"><input type="checkbox" name="q33" value="D"> D ifstream</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="A,C" data-explanation="T& operetor - pre
a T operetor-post">
    <div class="question">Podaj typowy nagłówek operatorów postdekrementacji i predekrementacji dla klasy o nazwie T</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q34" value="A"> A Predekrementacja T& operator--();</label>
        <label class="option"><input type="checkbox" name="q34" value="B"> B Predekrementacja T operator--();</label>
        <label class="option"><input type="checkbox" name="q34" value="C"> C Postdekrementacja T operator--(int);</label>
        <label class="option"><input type="checkbox" name="q34" value="D"> D Postdekrementacja T& operator++(int);</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="B" data-explanation="Wynik Fibonacciego">
    <div class="question">co zostanie wyswietlone wskutek wykonania ponizszego kodu:</div>
    <pre class="code">template<int N> struct Fibb {
    enum { val = Fibb<N - 1>::val + Fibb<N - 2>::val };
};

template<> struct Fibb<1> {
    enum { val = 1 };
};

template<> struct Fibb<0> {
    enum { val = 0 };
};

int main() {
    cout << Fibb<3>::val;
}</pre>
    <div class="options">
        <label class="option"><input type="checkbox" name="q35" value="A"> A 0</label>
        <label class="option"><input type="checkbox" name="q35" value="B"> B 2</label>
        <label class="option"><input type="checkbox" name="q35" value="C"> C 1</label>
        <label class="option"><input type="checkbox" name="q35" value="D"> D 3</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<div class="card" data-correct="A,B,C,D" data-explanation="wszytskie poprawne">
    <div class="question">Przykładem dziedziczenia wielobazowego jest</div>
    <div class="options">
        <label class="option"><input type="checkbox" name="q36" value="A"> A class Wielob: public A, public Z, public Y, public IRunner, public Base2, public IRunner {}</label>
        <label class="option"><input type="checkbox" name="q36" value="B"> B class Animal: public IRunner, public IVoicer {}</label>
        <label class="option"><input type="checkbox" name="q36" value="C"> C class Child: public Banana, protected Base1, public IRrunner</label>
        <label class="option"><input type="checkbox" name="q36" value="D"> D class A: Y, Z {}</label>
    </div>
    <button onclick="checkAnswer(this)">Sprawdź</button>
    <p class="result"></p>
         <p class="explanation"></p>
</div>

<script>
function checkAnswer(button) {
    const card = button.parentNode;
    const correctAnswers = card.dataset.correct.split(',');
    const checkboxes = card.querySelectorAll('input[type="checkbox"]');
    let correctCount = 0;
    let totalChecked = 0;
    let checkedValues = []; // Pobrane zaznaczone wartosci
    checkboxes.forEach(checkbox => {
        if (checkbox.checked) {
            totalChecked++;
            checkedValues.push(checkbox.value);
            if (correctAnswers.includes(checkbox.value)) {
                correctCount++;
            }
        }
    });

    const allCorrect = (correctCount === correctAnswers.length) && (totalChecked === correctAnswers.length);

    const resultElement = card.querySelector('.result');
    const explanationElement = card.querySelector('.explanation');

    if (allCorrect) {
        resultElement.textContent = "Brawo! Wszystkie odpowiedzi poprawne!";
        resultElement.className = "result correct";
    } else {
        resultElement.textContent = "Niestety, spróbuj jeszcze raz.";
        resultElement.className = "result incorrect";
    }

    let correctAnswersText = "Poprawne odpowiedzi: " + correctAnswers.join(', '); // text
    explanationElement.textContent = card.dataset.explanation + ". " + correctAnswersText;
}
</script>

</body>
</html>